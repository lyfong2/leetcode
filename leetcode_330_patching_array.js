/**
 * @param {number[]} nums
 * @param {number} n
 * @return {number}
 */
var minPatches = function(nums, n) {
    let miss = 1;
    let added = 0; 
    let i = 0;
    // 意味著我們已經知道我們可以在中建立所有和[0,miss)。
    while (miss <= n) {
        // 判斷可否拼出那個數字
        if (i < nums.length && nums[i] <= miss) {
            miss += nums[i++];
        } else {
            miss += miss;
            added++;
        }
    }
    return added;
};

console.log(minPatches([1, 2, 4, 13, 43], 100));

// 說明: 
// 讓miss成為[0,n]可能會丟失的最小總和。
// 意味著我們已經知道我們可以在中建立所有和[0,miss)。

// 然後，如果num <= miss在給定的數組中有一個數字，則可以將其加到較小的總和中，
// 以建立所有總和[0, miss + num)。
// 如果不這樣做，則必須將這樣的數字添加到數組中，最好添加miss自身，以最大化覆蓋範圍。



// 示例：假設輸入為nums = [1, 2, 4, 13, 43]和n = 100。我們需要確保[1,100]範圍內的所有和都是可能的。
// 使用給定的數字1、2和4，我們已經可以建立從0到7的所有和，即範圍[0,8]。

// 1 + 2 + 4 = 7
// [0, 8]

// 但是我們無法建立和8，下一個給定的數字（13）太大。
// 因此，我們將8插入數組。然後，我們可以在[0,16）中建立所有和。

// [1, 2, 4, ^8, 13, 43]
// 7 + 8 = 15


// [0, 16)
// 我們需要在數組中插入16嗎？沒有！我們已經可以建立總和3，將給定的13加到我們得到的總和為16。
// [1, 2] + [13] = 16
 

// 我們還可以將13加到其他總和上，將範圍擴展到[0,29）。
// [1, 2, 4, ^8] + [13] = 28
// [0,29）


// 給定的43太大，無法求和29，因此我們必須在數組中插入29。
// [1, 2, 4, ^8, 13, ^29, 43]

// 這將我們的範圍擴展到[0,58）。
// 28 + ^29 = 57
// [0,58）

// 43 + 57 = 100
// [0, 101)
// 但隨後43變得有用，並將我們的範圍擴展到[0,101）。至此，我們完成了。

